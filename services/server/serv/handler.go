package serv

import (
	"bytes"
	"strings"
	"time"

	"github.com/joeyscat/qim"
	"github.com/joeyscat/qim/container"
	"github.com/joeyscat/qim/wire"
	"github.com/joeyscat/qim/wire/pkt"
	"go.uber.org/zap"
	"google.golang.org/protobuf/proto"
)

type ServHandler struct {
	r          *qim.Router
	cache      qim.SessionStorage
	dispatcher *ServerDispatcher
	lg         *zap.Logger
}

type ServerDispatcher struct {
}

var _ qim.Acceptor = (*ServHandler)(nil)
var _ qim.MessageListener = (*ServHandler)(nil)
var _ qim.StateListener = (*ServHandler)(nil)
var _ qim.Dispatcher = (*ServerDispatcher)(nil)

func NewServHandler(r *qim.Router, cache qim.SessionStorage, lg *zap.Logger) *ServHandler {
	return &ServHandler{
		r:          r,
		cache:      cache,
		dispatcher: &ServerDispatcher{},
		lg:         lg,
	}
}

// Accept implements qim.Acceptor
func (h *ServHandler) Accept(conn qim.Conn, timeout time.Duration) (string, qim.Meta, error) {
	_ = conn.SetReadDeadline(time.Now().Add(timeout))
	frame, err := conn.ReadFrame()
	if err != nil {
		return "", nil, err
	}

	var req pkt.InnerHandshakeReq
	_ = proto.Unmarshal(frame.GetPayload(), &req)

	h.lg.Info("Accept --", zap.String("serviceID", req.ServiceId))

	return req.ServiceId, nil, nil
}

// Disconnect implements qim.StateListener
func (h *ServHandler) Disconnect(channelID string) error {
	h.lg.Warn("close event", zap.String("channelID", channelID))
	return nil
}

// Receive implements qim.MessageListener
func (h *ServHandler) Receive(agent qim.Agent, payload []byte) {
	buf := bytes.NewBuffer(payload)
	packet, err := pkt.MustReadLogicPkt(buf)
	if err != nil {
		h.lg.Error("read packet error", zap.Error(err))
		return
	}

	var session *pkt.Session
	if packet.GetCommand() == wire.CommandLoginSignIn {
		server, _ := packet.GetMeta(wire.MetaDestServer)
		session = &pkt.Session{
			ChannelId: packet.ChannelId,
			GateId:    server.(string),
			Tags:      []string{"AutoGenerated"},
		}
	} else {
		// TODO
		session, err = h.cache.Get(packet.ChannelId)
		if err == qim.ErrSessionNil {
			_ = RespErr(agent, packet, pkt.Status_SessionNotFound)
			return
		} else if err != nil {
			_ = RespErr(agent, packet, pkt.Status_SystemException)
			return
		}
	}

	h.lg.Debug("receive message", zap.String("session", session.String()), zap.String("header", packet.Header.String()))

	err = h.r.Serve(packet, h.dispatcher, h.cache, session)
	if err != nil {
		h.lg.Warn(err.Error())
	}
}

func RespErr(agent qim.Agent, p *pkt.LogicPkt, status pkt.Status) error {
	packet := pkt.NewFrom(&p.Header)
	packet.Status = status
	packet.Flag = pkt.Flag_Response

	packet.AddStringMeta(wire.MetaDestChannels, p.Header.ChannelId)
	return container.Push(agent.ID(), packet)
}

// Push implements qim.Dispatcher
func (d *ServerDispatcher) Push(gateway string, channels []string, p *pkt.LogicPkt) error {
	p.AddStringMeta(wire.MetaDestChannels, strings.Join(channels, ","))
	return container.Push(gateway, p)
}
